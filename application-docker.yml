server:
  port: 8080

spring:
  application:
    name: customer
  datasource:
    username: 'rahulrkmb'
    url: jdbc:postgresql://postgres:5432/customer
    password: 'password'
  jpa:
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
        format_sql: 'true'
    hibernate:
      ddl-auto: update
    show-sql: 'true'
  config:
#    import: configserver:http://configuration-service:8084
    # use default configuration defined here if config server is unavailable
    import: optional:configserver:http://configuration-service:8084
  rabbitmq:
    host: localhost
    port: 5672
    username: guest
    password: guest

eureka:
  client:
    service-url:
      defaultZone: http://eureka-server:8761/eureka
    fetch-registry: true
    register-with-eureka: true

logging:
  level:
    org.hibernate.SQL: DEBUG
    org.hibernate.orm.schema: DEBUG
    org.hibernate.tool.hbm2ddl: DEBUG
    org.springframework.cloud.openfeign: DEBUG
    feign: DEBUG

management:
  endpoints:
    web:
      exposure:
        include: health
  endpoint:
    health:
      show-details: always
  health:
    circuitbreakers:
      enabled: true
  tracing:
    sampling:
      probability: 1.0
  zipkin:
    tracing:
      endpoint: http://zipkin:9411/api/v2/spans


resilience4j:
  circuitbreaker:
    instances:
      # customer breaker is the custom circuit breaker instance created in our use case.
      customerBreaker:
        registerHealthIndicator: true # make the circuit breaker insights though actuator health
        slidingWindowSize: 10 # Number of request that can be stored in the sliding window where fault are counted
        minimumNumberOfCalls: 5 # Minimum number of calls required in the sliding window to identify the fault.
        permittedNumberOfCallsInHalfOpenState: 3 # Count of calls to check if the failed service up and running again.
        waitDurationInOpenState: 10s # wait duration in OPEN_STATE to move to HALF_OPEN state
        failureRateThreshold: 50 # Failure percentage to confirm a service is in fault.
        register-health-indicator: true
        automatic-transition-from-open-to-half-open-enabled: true
        sliding-window-type: count_based # Determine the fault identification method : "Count Based" / "Time Based"
  retry:
    instances:
      customerRetry:
        maxAttempts: 5 # Maximum number of retry during the failure of method annotated with @Retry
        waitDuration: 2s # Wait duration after each retry.
  ratelimiter:
    instances:
      customerRateLimiter:
        # RL wait for 0 sec for requests after the limit is exceeded.
        # If it gets permission those request are sent through else fall back function is executed
        timeout-duration: 0s
        limit-refresh-period: 4s # period at which limit is refreshed.
        limit-for-period: 2 # number of calls allowed. Post this limit , calls can only be made after 4 sec

